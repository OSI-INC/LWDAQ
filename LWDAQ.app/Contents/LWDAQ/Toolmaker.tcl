<script>
# Reception Average, a Neuroarchiver Analysis Script.
# Run this script in the LWDAQ Toolmaker.
# (C) 2011-2018, Kevan Hashemi, OSI Inc.
#
# This analysis produces a graph of average reception efficiency, as a
# percentage of the messages transmitted, during consecutive averaging periods
# we define in seconds. As input, the analysis takes a series of characteristics
# files that we select with a file browser. Each line in these files must be of
# the following format.

# archivename archivetime id reception c1 c2 ...c_n id...

# Here c1..cn are n characteristics generated by some processor, but the first
# characteristic is reception as a percentage of nominal. Many processors
# produce an output of this form. This reception-averaging script is designed to
# extract the reception values from these characteristics lines and generate the
# average reception in, for example, hour-long intervals so we can plot
# reception versus time. The analysis supports any number of other
# characteristics being present in the line, or even n=0 where reception is the
# only characteristic in the line. All characteristics must be real-valued
# numbers with a decimal point, so this script can find the reception after the
# ID number in each line without knowing how many other real-valued
# characteristics are present.

# The analysis deduces the playback interval by looking at the first two lines
# in the first file and subtracting their archive times.
# 
# The output of this script appears in the Toolmaker execution window. Each line
# in the window is the average reception for selected channels, calculated over
# the one averaging interval.

# The select string allows us to list the transmitter channels we want to
# examine.

# Number of seconds over which you wish to take the average power.
set averaging_interval 120

# Channels to analyze.
set select "75 76 100 109"

# We write a title line to the screen for the benefit of spreadsheet plots.
LWDAQ_print $t "Time $select"

# We select a list of files in a browser. We sort them in order of
# increasing time stamp.
set fnl [lsort -dictionary [LWDAQ_get_file_name 1]]

# We initialize some variables used in the analysis.
set previous_clock_seconds 0
set start_clock_seconds 0
set count 0
foreach id $select {
  set reception_$id 0
}

# We go through the files and set our start time based upon the file
# name.
foreach fn $fnl {
  if {![regexp -nocase {M([0-9]{10}).*?\.txt} $fn match file_clock_seconds]} {
    error "File [file tail $fn] has invalid name."
  }
  if {$previous_clock_seconds == 0} {
    set previous_clock_seconds $file_clock_seconds
    set start_clock_seconds $file_clock_seconds
  }
  
  # Read the characteristics from the file into a list.
  set f [open $fn r]
  set characteristics [string trim [read $f]]
  close $f
  set characteristics [split $characteristics \n]

  # Go through all the characteristics lines.
  for {set i 0} {$i < [llength $characteristics]} {incr i} { 

    # We get the i'th characteristics line from the list.
    set r [lindex $characteristics $i]

    # We go through each selected id, find the elements in the characteristics
    # line that correspond to this id, if any, and add all the band powers to
    # their current sums, and increment the band power counters. We don't want
    # to confuse the archive time for an id, which we might at the beginning of
    # an archive, so we skip the first two elements of the line, which are the
    # file name and the archive time.
    foreach id $select {
      set index [lsearch -start 2 $r $id]
      if {$index >= 0} {
        set reception_$id [expr [set reception_$id] + [lindex $r [expr $index + 1]]]
      }
    }
    
    # Increment the interval counter.
    incr count
    
    # We obtain the time of this line from the file name and the time given
    # in the second element of the characteristics line.
    set clock_seconds [expr $file_clock_seconds + [lindex $r 1]]

    # Whenever we have accumulated an averaging interval's worth of data,
    # we print the averages to the screen along with the time from the start
    # of our calculation. To plot the averages, we copy from the Toolmaker 
    # execution window into a spreadsheet.    
    if {[expr $clock_seconds - $previous_clock_seconds] >= $averaging_interval} {
      set result "[expr round($clock_seconds) - $start_clock_seconds] "
      foreach id $select {
        append result [format %.1f [expr [set reception_$id] / $count]]
        append result " "
      }
      set previous_clock_seconds $clock_seconds
      foreach id $select {set reception_$id 0}
      set count 0
      LWDAQ_print $t $result
    }
    LWDAQ_support
    if {![winfo exists $t]} {break}
  }
}
</script>

